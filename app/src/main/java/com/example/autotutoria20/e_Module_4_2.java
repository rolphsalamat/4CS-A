package com.example.autotutoria20;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class e_Module_4_2 {

    /*
    +----------------------+
    |       PRE-TEST       |
    |       LESSON 2       |
    +----------------------+
    */

    public static e_Question[] get_PreTest_Lesson2_Questions() {
        return e_Module_4.getPreTestQuestions(
                pre_test_lesson_2_questions,
                pre_test_lesson_2_choices,
                pre_test_lesson_2_answers
        );
    }

    public static final String[] pre_test_lesson_2_questions = {
            /*1*/    "What does a Context-Free Grammar (CFG) primarily consist of?",
            /*2*/    "Which of the following is a terminal in a CFG?",
            /*3*/    "What does the start symbol in a CFG represent?",
            /*4*/    "Which of the following is NOT a component of a CFG?",
            /*5*/    "In the CFG `S → aSb | ε` what does `ε` represent?",
            /*6*/    "Which of the following languages can a CFG describe?",
            /*7*/    "What is the role of production rules in a CFG?",
            /*8*/    "In a CFG what does a non-terminal symbol represent?",
            /*9*/    "Which of the following is an example of a CFG generating a string of balanced parentheses?",
            /*10*/   "What type of language can CFGs describe that regular languages cannot?",
            /*11*/   "In a CFG for arithmetic expressions, which component is likely to be a non-terminal?",
            /*12*/   "What does the production rule `S → aSb` generate?",
            /*13*/   "Which of the following is a valid string generated by the CFG `S → aSb | ε`?",
            /*14*/   "What kind of recursion is used in the CFG `S → aSb`?",
            /*15*/   "Which of the following production rules is used to end the recursion in a CFG?"
    };

    public static final String[][] pre_test_lesson_2_choices = {
            /*1*/    {"Terminals, Non-terminals, Production rules, and Start symbol", "Only Terminals and Non-terminals", "Only Start symbols and Production rules", "Terminals and Variables"},
            /*2*/    {"A non-terminal symbol", "An actual character in the language", "A placeholder for a set of rules", "The start symbol"},
            /*3*/    {"A sequence of terminals", "The entire language to be generated", "A terminal symbol", "A production rule"},
            /*4*/    {"Terminals", "Non-terminals", "Syntax trees", "Production rules"},
            /*5*/    {"An empty string", "A terminal", "A non-terminal", "A recursive symbol"},
            /*6*/    {"Arithmetic expressions", "Balanced parentheses", "Both a and b", "None of the above"},
            /*7*/    {"To specify how terminals and non-terminals can be replaced", "To enforce syntax errors", "To check for valid input", "To define the length of strings"},
            /*8*/    {"A final character in the string", "A symbol that can be replaced by terminals or other non-terminals", "A special operator", "An undefined variable"},
            /*9*/    {"S → (S)", "S → (S) | ε", "S → (S) | SS | ε", "S → (())"},
            /*10*/   {"Languages with balanced parentheses", "Languages with a fixed number of symbols", "Simple languages with no recursion", "Languages with finite patterns"},
            /*11*/   {"A number", "An operator like `+` or `*`", "An expression", "A parenthesis"},
            /*12*/   {"Strings with an equal number of 'a's and 'b's", "Strings with more 'a's than 'b's", "Strings with more 'b's than 'a's", "Strings with only 'a's"},
            /*13*/   {"ab", "aab", "aabb", "aaabbb"},
            /*14*/   {"Left recursion", "Right recursion", "Direct recursion", "Indirect recursion"},
            /*15*/   {"S → aSb", "S → SS", "S → ε", "S → SSS"}
    };

    public static final int[] pre_test_lesson_2_answers = {
            /*1*/    0, // 'Terminals, Non-terminals, Production rules, and Start symbol'
            /*2*/    1, // 'An actual character in the language'
            /*3*/    1, // 'The entire language to be generated'
            /*4*/    2, // 'Syntax trees'
            /*5*/    0, // 'An empty string'
            /*6*/    2, // 'Both a and b'
            /*7*/    0, // 'To specify how terminals and non-terminals can be replaced'
            /*8*/    1, // 'A symbol that can be replaced by terminals or other non-terminals'
            /*9*/    2, // 'S → (S) | SS | ε'
            /*10*/   0, // 'Languages with balanced parentheses'
            /*11*/   2, // 'An expression'
            /*12*/   0, // 'Strings with an equal number of 'a's and 'b's'
            /*13*/   2, // 'aabb'
            /*14*/   1, // 'Right recursion'
            /*15*/   2  // 'S → ε'
    };

    /*
    +----------------------+
    |       POST-TEST      |
    |          EASY        |
    +----------------------+
    */

    public static e_Question[] get_PostTest_Lesson2_Easy_Questions() {
        return e_Module_4.get_PostTest_EasyMedium_Questions(
                post_test_lesson_2_questions_easy,
                post_test_lesson_2_choices_easy,
                post_test_lesson_2_answers_easy,
                e_Question.Difficulty.EASY
        );
    }

    public static final String[] post_test_lesson_2_questions_easy = {
            /*1*/    "A context-free grammar (CFG) is a set of recursive rules used to generate strings in a language.",
            /*2*/    "Terminals are symbols that cannot be broken down further into smaller units in a CFG.",
            /*3*/    "Non-terminals represent the smallest units of a language and cannot be replaced by other symbols.",
            /*4*/    "The start symbol in a CFG is used to represent the entire sentence or program in the language.",
            /*5*/    "A production rule replaces a terminal symbol with a string of non-terminals.",
            /*6*/    "In CFGs, terminals form the 'alphabet' of the language.",
            /*7*/    "Non-terminals cannot be further expanded or replaced by other symbols according to the production rules.",
            /*8*/    "The start symbol is a terminal symbol in a CFG.",
            /*9*/    "Production rules define how terminals and non-terminals combine to form valid strings.",
            /*10*/   "The format of a production rule is typically written as A → α where A is a non-terminal.",
            /*11*/   "A CFG can only generate strings that consist of terminal symbols.",
            /*12*/   "Non-terminals are placeholders for patterns of terminals and cannot be part of production rules.",
            /*13*/   "In CFGs the start symbol is always denoted as 'S'.",
            /*14*/   "The purpose of non-terminals in a CFG is to define the structure of the language.",
            /*15*/   "Terminals and non-terminals in CFGs are combined according to production rules to form valid strings in the language."
    };

    public static final String[][] post_test_lesson_2_choices_easy = {
            /*1*/    {"True", "False"},
            /*2*/    {"True", "False"},
            /*3*/    {"True", "False"},
            /*4*/    {"True", "False"},
            /*5*/    {"True", "False"},
            /*6*/    {"True", "False"},
            /*7*/    {"True", "False"},
            /*8*/    {"True", "False"},
            /*9*/    {"True", "False"},
            /*10*/   {"True", "False"},
            /*11*/   {"True", "False"},
            /*12*/   {"True", "False"},
            /*13*/   {"True", "False"},
            /*14*/   {"True", "False"},
            /*15*/   {"True", "False"}
    };

    public static final int[] post_test_lesson_2_answers_easy = {
            /*1*/    0, // True
            /*2*/    0, // True
            /*3*/    1, // False
            /*4*/    0, // True
            /*5*/    1, // False
            /*6*/    0, // True
            /*7*/    1, // False
            /*8*/    1, // False
            /*9*/    0, // True
            /*10*/   0, // True
            /*11*/   1, // False
            /*12*/   1, // False
            /*13*/   0, // True
            /*14*/   0, // True
            /*15*/   0  // True
    };

    /*
    +----------------------+
    |       POST-TEST      |
    |        MEDIUM        |
    +----------------------+
    */

    public static e_Question[] get_PostTest_Lesson2_Medium_Questions() {
        return e_Module_4.get_PostTest_EasyMedium_Questions(
                post_test_lesson_2_questions_medium,
                post_test_lesson_2_choices_medium,
                post_test_lesson_2_answers_medium,
                e_Question.Difficulty.MEDIUM);
    }

    public static final String[] post_test_lesson_2_questions_medium = {
            /*1*/    "What is a context-free grammar (CFG)?",
            /*2*/    "Which of the following are considered terminals in a CFG?",
            /*3*/    "Non-terminals in a CFG are:",
            /*4*/    "The start symbol in a CFG:",
            /*5*/    "A production rule is:",
            /*6*/    "Which of the following best describes terminals?",
            /*7*/    "Which is an example of a non-terminal in an arithmetic expression grammar?",
            /*8*/    "The format of a production rule is typically written as:",
            /*9*/    "The start symbol in a CFG:",
            /*10*/   "Which of the following is an example of a terminal symbol in a CFG for arithmetic expressions?",
            /*11*/   "Production rules in CFGs define:",
            /*12*/   "Which is true about non-terminals in CFGs?",
            /*13*/   "The purpose of the start symbol in a CFG is to:",
            /*14*/   "In a CFG terminals and non-terminals:",
            /*15*/   "Which of the following is NOT a component of a CFG?"
    };

    public static final String[][] post_test_lesson_2_choices_medium = {
            /*1*/    {"A set of terminal symbols used to define a language.", "A set of recursive rules used to generate strings in a language.", "A method for analyzing non-terminals.", "A system of organizing sentences."},
            /*2*/    {"Placeholders for patterns.", "Basic symbols that cannot be further divided.", "Non-terminal symbols.", "Start symbols."},
            /*3*/    {"The smallest units of the language.", "Symbols that represent patterns of terminals and non-terminals.", "The 'alphabet' of the language.", "Replaced by terminals only."},
            /*4*/    {"Is a terminal symbol.", "Represents the entire language.", "Is the beginning point for generating strings.", "Can only appear in the middle of a string."},
            /*5*/    {"A transformation that replaces a terminal with a non-terminal.", "A rule that replaces a non-terminal with a string of terminals and non-terminals.", "A method to rewrite only terminal symbols.", "A way to rearrange terminals within a language."},
            /*6*/    {"Symbols that can be replaced by non-terminals.", "The smallest indivisible units of the language.", "Symbols that are always replaced by production rules.", "Non-terminal symbols that form the base of a language."},
            /*7*/    {"+", "Term", "1", "("},
            /*8*/    {"A → α where A is a terminal.", "A → α where A is a non-terminal and α is a string of terminals and non-terminals.", "A → B where A and B are both terminals.", "A → B + C where A is a terminal and B and C are non-terminals."},
            /*9*/    {"Is always denoted as ‘S’.", "Is always a terminal.", "Is a special non-terminal from which string generation begins.", "Can be replaced only by terminal symbols."},
            /*10*/   {"Expr", "Term", "+", "Factor"},
            /*11*/   {"How terminals can be expanded into non-terminals.", "How non-terminals can be replaced by strings of terminals and non-terminals.", "How to generate terminals only.", "How the start symbol is defined."},
            /*12*/   {"They are always replaced by terminals.", "They can be replaced by both terminals and other non-terminals.", "They cannot be part of production rules.", "They are the same as terminals."},
            /*13*/   {"Begin the generation of strings.", "End the generation of strings.", "Represent a terminal symbol.", "Denote the final output of the CFG."},
            /*14*/   {"Are defined by the start symbol.", "Are combined according to production rules to form valid strings.", "Can only appear at the end of a string.", "Cannot appear together in the same production rule."},
            /*15*/   {"Terminals", "Non-terminals", "Start symbol", "Alphabet symbol"}
    };

    public static final int[] post_test_lesson_2_answers_medium = {
            /*1*/    1, // A set of recursive rules used to generate strings in a language.
            /*2*/    1, // Basic symbols that cannot be further divided.
            /*3*/    1, // Symbols that represent patterns of terminals and non-terminals.
            /*4*/    2, // The beginning point for generating strings.
            /*5*/    1, // A rule that replaces a non-terminal with a string of terminals and non-terminals.
            /*6*/    1, // The smallest indivisible units of the language.
            /*7*/    1, // Term
            /*8*/    1, // A → α where A is a non-terminal and α is a string of terminals and non-terminals.
            /*9*/    2, // Is a special non-terminal from which string generation begins.
            /*10*/   2, // +
            /*11*/   1, // How non-terminals can be replaced by strings of terminals and non-terminals.
            /*12*/   1, // They can be replaced by both terminals and other non-terminals.
            /*13*/   0, // Begin the generation of strings.
            /*14*/   1, // Are combined according to production rules to form valid strings.
            /*15*/   3  // Alphabet symbol
    };

    /*
    +----------------------+
    |       POST-TEST      |
    |         HARD         |
    +----------------------+
    */

    public static e_Question[] get_PostTest_Lesson2_Hard_Questions() {
        return e_Module_4.get_PostTest_Hard_Questions(
                post_test_lesson_2_questions_hard,
                post_test_lesson_2_answers_hard,
                e_Question.Difficulty.HARD
        );
    }

    public static final String[] post_test_lesson_2_questions_hard = {
            /*1*/    "The smallest indivisible symbols in a context-free grammar that form the 'alphabet' of the language.",
            /*2*/    "A type of grammar used to define formal languages and generate patterns of strings using recursive rules.",
            /*3*/    "A component in a grammar that can be replaced by terminals or other non-terminal components defining the structure of the language.",
            /*4*/    "The special component in a CFG from which the generation of strings starts representing the entire structure of the language.",
            /*5*/    "The set of rules in a CFG that describe how non-terminal symbols are transformed into sequences of terminals and non-terminals.",
            /*6*/    "A set of rules that recursively generate all valid strings for a given formal language.",
            /*7*/    "Symbols in a CFG that are used to represent patterns and can be expanded into other symbols according to the production rules.",
            /*8*/    "The initial non-terminal symbol from which a context-free grammar starts generating a string.",
            /*9*/    "The process in a CFG where a non-terminal symbol is replaced by a string of terminals and/or other non-terminals.",
            /*10*/   "The basic symbols in a language that represent the literal elements such as keywords operators or literals and cannot be decomposed further.",
            /*11*/   "The part of a CFG that determines how a language's structure is defined by expanding non-terminal symbols into other symbols.",
            /*12*/   "A specific rule in a CFG that defines how one symbol can be transformed into a combination of others to form a valid string.",
            /*13*/   "The component of a CFG that signifies the starting point for generating a language's strings.",
            /*14*/   "The rule that describes the structure of an expression by transforming non-terminals into combinations of terminals and non-terminals.",
            /*15*/   "The special symbol in a CFG that determines where the derivation of the grammar starts."
    };

    public static final String[] post_test_lesson_2_answers_hard = {
            /*1*/    "terminals",
            /*2*/    "context-free grammar",
            /*3*/    "non-terminal",
            /*4*/    "start symbol",
            /*5*/    "production rule",
            /*6*/    "context-free grammar",
            /*7*/    "non-terminals",
            /*8*/    "start symbol",
            /*9*/    "production rule",
            /*10*/   "terminals",
            /*11*/   "non-terminals",
            /*12*/   "production rule",
            /*13*/   "start symbol",
            /*14*/   "production rule",
            /*15*/   "start symbol"
    };
}