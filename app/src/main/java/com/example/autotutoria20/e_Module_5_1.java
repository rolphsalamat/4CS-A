package com.example.autotutoria20;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class e_Module_5_1 {

    /*
    +----------------------+
    |       PRE-TEST       |
    +----------------------+
    */

    public static e_Question[] get_PreTest_Lesson1_Questions() {
        return e_Module_5.getPreTestQuestions(
                pre_test_lesson_1_questions,
                pre_test_lesson_1_choices,
                pre_test_lesson_1_answers
        );
    }

    public static final String[] pre_test_lesson_1_questions = {
            /*1*/   "What is a Context-Free Grammar (CFG)?",
            /*2*/   "Which of the following is NOT a component of a CFG?",
            /*3*/   "What are Terminals in a CFG?",
            /*4*/   "What is the role of Non-terminals in a CFG?",
            /*5*/   "In a CFG, what does the Start Symbol represent?",
            /*6*/   "Which of the following is an example of a terminal in an arithmetic expression CFG?",
            /*7*/   "Which of the following is an example of a non-terminal in an arithmetic expression CFG?",
            /*8*/   "Which production rule format is correct?",
            /*9*/   "What is the function of production rules in a CFG?",
            /*10*/  "Which of the following is a valid production rule in a CFG for arithmetic expressions?",
            /*11*/  "What is typically the start symbol in a CFG for arithmetic expressions?",
            /*12*/  "Which of the following describes the terminal symbols in a CFG for arithmetic expressions?",
            /*13*/  "In the production rule 'Term → Term ∗ Factor', which are the non-terminal symbols?",
            /*14*/  "What does the production rule 'Factor → number' signify in the CFG for arithmetic expressions?",
            /*15*/  "Which of the following sentences can be generated by the CFG provided in the lesson?"
    };

    public static final String[][] pre_test_lesson_1_choices = {
            /*1*/   {"A set of keywords in a programming language", "A set of recursive rewriting rules used to generate patterns of strings", "A method for compiling programs", "A framework for error handling in code"},
            /*2*/   {"Terminals", "Non-terminals", "Start Symbol", "Semantic Analyzer"},
            /*3*/   {"Placeholders for patterns of terminals and non-terminals", "Basic symbols from which strings are formed", "Symbols that represent the start of the string", "Rules for combining non-terminals"},
            /*4*/   {"They define the structure of the language", "They are the basic symbols of the language", "They replace production rules", "They are literals in the language"},
            /*5*/   {"The smallest unit of the language", "The point from which the generation of strings begins", "The symbol that ends the string", "A rule for combining terminals"},
            /*6*/   {"Expr", "Term", "+", "Factor"},
            /*7*/   {"+", "5", "Expr", "/"},
            /*8*/   {"A → α", "α → A", "A → A", "α → α"},
            /*9*/   {"They generate new terminal symbols", "They define how symbols can be combined", "They delete non-terminals", "They stop the grammar from expanding"},
            /*10*/  {"Expr → 5", "Expr → Expr + Term", "Term → Term - Factor", "Factor → Expr + Term"},
            /*11*/  {"Term", "Expr", "Factor", "Number"},
            /*12*/  {"Numbers, operators, and parentheses", "Expressions, terms, and factors", "Variables, expressions, and functions", "Sentences, clauses, and words"},
            /*13*/  {"Term and ∗", "Term and Factor", "∗ and Factor", "Term only"},
            /*14*/  {"A factor can be replaced by an expression", "A factor can be replaced by a number", "A number is the same as a term", "A factor is a terminal symbol"},
            /*15*/  {"3 + 5 ∗ (2 − 8)", "Expr + Term", "Factor + Factor", "Expr ∗ number"}
    };

    public static final int[] pre_test_lesson_1_answers = {
            /*1*/   1, // 'A set of recursive rewriting rules used to generate patterns of strings'
            /*2*/   3, // 'Semantic Analyzer'
            /*3*/   1, // 'Basic symbols from which strings are formed'
            /*4*/   0, // 'They define the structure of the language'
            /*5*/   1, // 'The point from which the generation of strings begins'
            /*6*/   2, // '+'
            /*7*/   2, // 'Expr'
            /*8*/   0, // 'A → α'
            /*9*/   1, // 'They define how symbols can be combined'
            /*10*/  1, // 'Expr → Expr + Term'
            /*11*/  1, // 'Expr'
            /*12*/  0, // 'Numbers, operators, and parentheses'
            /*13*/  1, // 'Term and Factor'
            /*14*/  1, // 'A factor can be replaced by a number'
            /*15*/  0  // '3 + 5 ∗ (2 − 8)'
    };

    /*
    +----------------------+
    |       POST-TEST      |
    |          EASY        |
    +----------------------+
    */

    public static e_Question[] get_PostTest_Lesson1_Easy_Questions() {
        return e_Module_5.get_PostTest_EasyMedium_Questions(
                post_test_lesson_1_questions_easy,
                post_test_lesson_1_choices_easy,
                post_test_lesson_1_answers_easy,
                e_Question.Difficulty.EASY
        );
    }

    public static final String[] post_test_lesson_1_questions_easy = {
            /*1*/   "A parse tree represents the syntactic structure of a string based on a given grammar.",
            /*2*/   "In a parse tree, the leaves represent non-terminal symbols.",
            /*3*/   "The root of a parse tree represents the start symbol of the grammar.",
            /*4*/   "Each branch of a parse tree corresponds to a production rule of the grammar.",
            /*5*/   "A parse tree is only used in programming languages, not in natural language processing.",
            /*6*/   "The terminals in a parse tree are the final outputs of the grammar rules.",
            /*7*/   "The internal nodes of a parse tree represent the terminals of the grammar.",
            /*8*/   "Parse trees are a type of binary tree.",
            /*9*/   "A parse tree can be ambiguous, leading to more than one valid tree for a given string.",
            /*10*/  "The leaves of a parse tree represent the terminal symbols of the language being parsed.",
            /*11*/  "Every string generated by a context-free grammar can have exactly one unique parse tree.",
            /*12*/  "A parse tree always has a node for each symbol in the input string.",
            /*13*/  "Parse trees are used to validate whether a given string belongs to the language defined by the grammar.",
            /*14*/  "Parse trees can be constructed for both deterministic and non-deterministic context-free grammars.",
            /*15*/  "A parse tree is a representation that only applies to lexical analysis."
    };

    public static final String[][] post_test_lesson_1_choices_easy = {
            /*1*/   {"True", "False"},
            /*2*/   {"True", "False"},
            /*3*/   {"True", "False"},
            /*4*/   {"True", "False"},
            /*5*/   {"True", "False"},
            /*6*/   {"True", "False"},
            /*7*/   {"True", "False"},
            /*8*/   {"True", "False"},
            /*9*/   {"True", "False"},
            /*10*/  {"True", "False"},
            /*11*/  {"True", "False"},
            /*12*/  {"True", "False"},
            /*13*/  {"True", "False"},
            /*14*/  {"True", "False"},
            /*15*/  {"True", "False"}
    };

    public static final int[] post_test_lesson_1_answers_easy = {
            /*1*/   0, // True
            /*2*/   1, // False
            /*3*/   0, // True
            /*4*/   0, // True
            /*5*/   1, // False
            /*6*/   0, // True
            /*7*/   1, // False
            /*8*/   1, // False
            /*9*/   0, // True
            /*10*/  0, // True
            /*11*/  1, // False
            /*12*/  0, // True
            /*13*/  0, // True
            /*14*/  0, // True
            /*15*/  1  // False
    };

    /*
    +----------------------+
    |       POST-TEST      |
    |        MEDIUM        |
    +----------------------+
    */

    public static e_Question[] get_PostTest_Lesson1_Medium_Questions() {
        return e_Module_5.get_PostTest_EasyMedium_Questions(
                post_test_lesson_1_questions_medium,
                post_test_lesson_1_choices_medium,
                post_test_lesson_1_answers_medium,
                e_Question.Difficulty.MEDIUM
        );
    }

    public static final String[] post_test_lesson_1_questions_medium = {
            /*1*/   "Which of the following is true about a parse tree?",
            /*2*/   "What do the leaves of a parse tree represent?",
            /*3*/   "The root of a parse tree is typically associated with which element?",
            /*4*/   "Which of the following is NOT true about parse trees?",
            /*5*/   "In a parse tree, which of the following components is associated with non-terminal symbols?",
            /*6*/   "What is the purpose of constructing a parse tree?",
            /*7*/   "Which of the following best describes an ambiguous grammar?",
            /*8*/   "Which of the following statements is true about terminal symbols in a parse tree?",
            /*9*/   "What is the main difference between a parse tree and an abstract syntax tree (AST)?",
            /*10*/  "Which of the following is an essential step in constructing a parse tree?",
            /*11*/  "Which of the following is true about ambiguous grammars?",
            /*12*/  "In a parse tree, the process of applying production rules starts from:",
            /*13*/  "Which type of grammar typically constructs parse trees?",
            /*14*/  "Which of the following is NOT an element found in a parse tree?",
            /*15*/  "Which of the following structures is used to represent the hierarchical structure of a language's syntax?"
    };

    public static final String[][] post_test_lesson_1_choices_medium = {
            /*1*/   {"The root represents the terminal symbol", "The leaves represent non-terminal symbols", "The internal nodes represent the production rules", "The leaves represent the start symbol"},
            /*2*/   {"Non-terminal symbols", "The input string", "Production rules", "Terminal symbols"},
            /*3*/   {"A terminal symbol", "The start symbol of the grammar", "A non-terminal symbol", "A production rule"},
            /*4*/   {"They represent the syntactic structure of a string", "They can have more than one valid form for ambiguous grammars", "They are only used in lexical analysis", "The leaves represent terminal symbols"},
            /*5*/   {"Internal nodes", "Leaf nodes", "Terminal symbols", "Edges"},
            /*6*/   {"To break down a sentence into words", "To represent the syntactic structure of a string based on grammar", "To generate lexical tokens", "To find ambiguities in the input string"},
            /*7*/   {"A grammar that cannot generate a valid parse tree", "A grammar with multiple start symbols", "A grammar that generates more than one valid parse tree for a single string", "A grammar with no terminal symbols"},
            /*8*/   {"They appear at the root of the tree", "They are located at the leaves of the tree", "They correspond to the non-terminal symbols of the grammar", "They represent the production rules"},
            /*9*/   {"An AST represents all the production rules, while a parse tree does not", "A parse tree shows all the syntactic details, while an AST abstracts unnecessary details", "A parse tree is used in lexical analysis and an AST is used in syntax analysis", "An AST is more commonly used in natural language processing"},
            /*10*/  {"Identifying the lexical tokens of the input string", "Starting from the terminal symbols and moving upward", "Applying production rules starting from the root node", "Labeling each node with a numerical value"},
            /*11*/  {"They can result in multiple valid parse trees for the same string", "They always produce only one parse tree", "They cannot be used to generate any valid parse tree", "They are used exclusively in machine learning"},
            /*12*/  {"The leaves and moves upwards", "The root and moves downwards", "The leftmost terminal symbol", "The rightmost non-terminal symbol"},
            /*13*/  {"Regular grammar", "Context-free grammar", "Context-sensitive grammar", "Unrestricted grammar"},
            /*14*/  {"Terminal symbols", "Production rules", "Non-terminal symbols", "Ambiguous rules"},
            /*15*/  {"Finite State Automaton", "Lexical Analyzer", "Parse Tree", "Transition Table"}
    };

    public static final int[] post_test_lesson_1_answers_medium = {
            /*1*/   2, // The internal nodes represent the production rules
            /*2*/   3, // Terminal symbols
            /*3*/   1, // The start symbol of the grammar
            /*4*/   2, // They are only used in lexical analysis
            /*5*/   0, // Internal nodes
            /*6*/   1, // To represent the syntactic structure of a string based on grammar
            /*7*/   2, // A grammar that generates more than one valid parse tree for a single string
            /*8*/   1, // They are located at the leaves of the tree
            /*9*/   1, // A parse tree shows all the syntactic details, while an AST abstracts unnecessary details
            /*10*/  2, // Applying production rules starting from the root node
            /*11*/  0, // They can result in multiple valid parse trees for the same string
            /*12*/  1, // The root and moves downwards
            /*13*/  1, // Context-free grammar
            /*14*/  3, // Ambiguous rules
            /*15*/  2  // Parse Tree
    };

    /*
    +----------------------+
    |       POST-TEST      |
    |         HARD         |
    +----------------------+
    */

    public static e_Question[] get_PostTest_Lesson1_Hard_Questions() {
        return e_Module_5.get_PostTest_Hard_Questions(
                post_test_lesson_1_questions_hard,
                post_test_lesson_1_answers_hard,
                e_Question.Difficulty.HARD
        );
    }

    public static final String[] post_test_lesson_1_questions_hard = {
            /*1*/   "Identify the structure that represents the syntactic structure of a string based on a given grammar.",
            /*2*/   "What is the term for the symbols located at the leaves of a parse tree?",
            /*3*/   "What is the element at the root of a parse tree typically associated with a grammar's start symbol?",
            /*4*/   "What is the term for the rules that connect non-terminal symbols in a parse tree?",
            /*5*/   "Identify the type of grammar that is typically used to construct parse trees.",
            /*6*/   "What is the term for a grammar that allows for multiple valid parse trees for a single string?",
            /*7*/   "What do we call the nodes in a parse tree that represent non-terminal symbols?",
            /*8*/   "Identify the part of the parse tree that represents the final outputs of the grammar.",
            /*9*/   "What do you call a type of tree that abstracts away unnecessary syntactic details unlike a parse tree?",
            /*10*/  "What is the name of the process that involves starting from the root of a parse tree and applying production rules to generate the structure?",
            /*11*/  "What is the method of starting from a non-terminal symbol and applying production rules to generate a parse tree?",
            /*12*/  "What is the part of a grammar that defines the structure of the strings in the language typically used in constructing parse trees?",
            /*13*/  "Identify the term used for the smallest individual elements of a language that a parse tree analyzes.",
            /*14*/  "What is the process called that checks if a string conforms to the rules of a given grammar often visualized through a parse tree?",
            /*15*/  "What is the structure used by compilers to ensure that code follows the syntactic rules of a programming language?"
    };

    public static final String[] post_test_lesson_1_answers_hard = {
            /*1*/   "parse tree",
            /*2*/   "terminal symbols",
            /*3*/   "start symbol",
            /*4*/   "production rules",
            /*5*/   "context-free grammar",
            /*6*/   "ambiguous grammar",
            /*7*/   "internal nodes",
            /*8*/   "terminal symbols",
            /*9*/   "abstract syntax tree",
            /*10*/  "parsing",
            /*11*/  "derivation",
            /*12*/  "syntax",
            /*13*/  "lexical tokens",
            /*14*/  "syntax analysis",
            /*15*/  "parse tree"
    };
}