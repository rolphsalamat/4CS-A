package com.example.autotutoria20;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class e_Module_6_2 {

    /*
    +----------------------+
    |       PRE-TEST       |
    +----------------------+
    */

    public static e_Question[] get_PreTest_Lesson2_Questions() {
        return e_Module_6.getPreTestQuestions(
                pre_test_lesson_2_questions,
                pre_test_lesson_2_choices,
                pre_test_lesson_2_answers
        );
    }

    public static final String[] pre_test_lesson_2_questions = {
            /*1*/    "What is a primary challenge when working with ambiguous grammars in computer language processing?",
            /*2*/    "In context-free grammars, ambiguity typically arises when:",
            /*3*/    "What type of derivation is typically used to resolve ambiguity in grammars?",
            /*4*/    "Which of the following would indicate that a grammar is unambiguous?",
            /*5*/    "When simplifying a grammar to remove ambiguity, which method is commonly used?",
            /*6*/    "Which of the following is not a factor that contributes to ambiguity in a grammar?",
            /*7*/    "What happens when a string has multiple valid parse trees?",
            /*8*/    "Which parsing technique would you choose to avoid ambiguity in grammars?",
            /*9*/    "When checking for ambiguity in a grammar, which part of the process is analyzed?",
            /*10*/   "Which of the following is a correct strategy to handle grammar ambiguity in a parser?",
            /*11*/   "Why is ambiguity problematic in context-free grammars used in programming languages?",
            /*12*/   "Which of the following grammars will always result in unambiguous parsing?",
            /*13*/   "Which is a key indicator that a grammar contains ambiguity?",
            /*14*/   "Ambiguous grammars are problematic in which context?",
            /*15*/   "Which concept describes a situation where a sentence can be derived from a grammar in multiple ways?"
    };

    public static final String[][] pre_test_lesson_2_choices = {
            /*1*/    {"Multiple meanings of a single string", "No possibility of generating terminal symbols", "Only one derivation is possible", "Left recursion is not allowed"},
            /*2*/    {"The same string has more than one valid parse tree", "Non-terminal symbols are not properly defined", "Only terminal symbols are present in the grammar", "There is no derivation for a string"},
            /*3*/    {"Leftmost derivation", "Rightmost derivation", "Both leftmost and rightmost derivation", "None of the above"},
            /*4*/    {"Every string generates exactly one parse tree", "Each string generates multiple derivation trees", "The grammar produces terminal symbols only", "All derivations start with a terminal symbol"},
            /*5*/    {"Removing left recursion", "Adding more terminal symbols", "Left factoring", "Adding random productions"},
            /*6*/    {"Overlapping rules for the same string", "Multiple leftmost derivations for a string", "No rightmost derivation possible for any string", "Multiple parse trees for a single string"},
            /*7*/    {"The string cannot be generated by the grammar", "The string is unambiguous", "The grammar is considered ambiguous", "The parse trees are considered invalid"},
            /*8*/    {"GLR parser", "SLR parser", "LL(1) parser", "All of the above"},
            /*9*/    {"Only the terminal symbols", "The number of parse trees generated for a string", "The total number of derivations for each string", "Whether each string contains non-terminal symbols"},
            /*10*/   {"Removing terminal symbols", "Adding more rules to the grammar", "Left factoring the grammar", "Ignoring ambiguous strings"},
            /*11*/   {"It leads to unclear instructions for the compiler", "It makes the grammar simpler to process", "It allows for more efficient code generation", "It ensures all strings have unique derivations"},
            /*12*/   {"Regular grammars", "Context-sensitive grammars", "Context-free grammars with no overlapping productions", "Ambiguous grammars"},
            /*13*/   {"There are only terminal symbols in the grammar", "It generates multiple parse trees for at least one string", "No derivation trees can be formed", "It only uses leftmost derivation"},
            /*14*/   {"Simple text processing", "Natural language processing", "Compiler design for programming languages", "Basic arithmetic evaluation"},
            /*15*/   {"Determinism", "Ambiguity", "Regularity", "Context-sensitivity"}
    };

    public static final int[] pre_test_lesson_2_answers = {
            /*1*/    0,  // Multiple meanings of a single string
            /*2*/    0,  // The same string has more than one valid parse tree
            /*3*/    2,  // Both leftmost and rightmost derivation
            /*4*/    0,  // Every string generates exactly one parse tree
            /*5*/    0,  // Removing left recursion
            /*6*/    2,  // No rightmost derivation possible for any string
            /*7*/    2,  // The grammar is considered ambiguous
            /*8*/    0,  // GLR parser
            /*9*/    1,  // The number of parse trees generated for a string
            /*10*/   2,  // Left factoring the grammar
            /*11*/   0,  // It leads to unclear instructions for the compiler
            /*12*/   0,  // Regular grammars
            /*13*/   1,  // It generates multiple parse trees for at least one string
            /*14*/   2,  // Compiler design for programming languages
            /*15*/   1   // Ambiguity
    };

    /*
    +----------------------+
    |       POST-TEST      |
    |          EASY        |
    +----------------------+
    */

    public static e_Question[] get_PostTest_Lesson2_Easy_Questions() {
        return e_Module_6.get_PostTest_EasyMedium_Questions(
                post_test_lesson_2_questions_easy,
                post_test_lesson_2_choices_easy,
                post_test_lesson_2_answers_easy,
                e_Question.Difficulty.EASY
        );
    }

    public static final String[] post_test_lesson_2_questions_easy = {
            /*1*/    "An unambiguous grammar ensures that every valid string has exactly one parse tree.",
            /*2*/    "All context-free grammars are unambiguous by definition.",
            /*3*/    "The unambiguous grammar can generate more than one parse tree for a single string.",
            /*4*/    "It is possible to eliminate ambiguity from any given grammar.",
            /*5*/    "A grammar is said to be unambiguous if it produces multiple leftmost derivations for a sentence.",
            /*6*/    "If a grammar is unambiguous, it cannot be used in compilers.",
            /*7*/    "Unambiguous grammars are useful when dealing with natural languages.",
            /*8*/    "Removing ambiguity from a grammar always leads to a more complex grammar structure.",
            /*9*/    "Unambiguous grammars cannot be used to define programming languages.",
            /*10*/   "Ambiguity can exist in a context-free grammar even if it is well-formed.",
            /*11*/   "The Chomsky Normal Form (CNF) helps to ensure a grammar is unambiguous.",
            /*12*/   "Unambiguous grammars are considered ideal for defining formal languages.",
            /*13*/   "In unambiguous grammars, every production rule must generate exactly one derivation.",
            /*14*/   "The process of transforming an ambiguous grammar to an unambiguous one can sometimes eliminate valid sentences.",
            /*15*/   "Every regular grammar is automatically unambiguous."
    };

    public static final String[][] post_test_lesson_2_choices_easy = {
            /*1*/    {"True", "False"},
            /*2*/    {"True", "False"},
            /*3*/    {"True", "False"},
            /*4*/    {"True", "False"},
            /*5*/    {"True", "False"},
            /*6*/    {"True", "False"},
            /*7*/    {"True", "False"},
            /*8*/    {"True", "False"},
            /*9*/    {"True", "False"},
            /*10*/   {"True", "False"},
            /*11*/   {"True", "False"},
            /*12*/   {"True", "False"},
            /*13*/   {"True", "False"},
            /*14*/   {"True", "False"},
            /*15*/   {"True", "False"}
    };

    public static final int[] post_test_lesson_2_answers_easy = {
            /*1*/    0,  // True
            /*2*/    1,  // False
            /*3*/    1,  // False
            /*4*/    1,  // False
            /*5*/    1,  // False
            /*6*/    1,  // False
            /*7*/    0,  // True
            /*8*/    1,  // False
            /*9*/    1,  // False
            /*10*/   0,  // True
            /*11*/   1,  // False
            /*12*/   0,  // True
            /*13*/   1,  // False
            /*14*/   0,  // True
            /*15*/   0   // True
    };

    /*
    +----------------------+
    |       POST-TEST      |
    |        MEDIUM        |
    +----------------------+
    */

    public static e_Question[] get_PostTest_Lesson2_Medium_Questions() {
        return e_Module_6.get_PostTest_EasyMedium_Questions(
                post_test_lesson_2_questions_medium,
                post_test_lesson_2_choices_medium,
                post_test_lesson_2_answers_medium,
                e_Question.Difficulty.MEDIUM
        );
    }

    public static final String[] post_test_lesson_2_questions_medium = {
            /*1*/    "What defines an unambiguous grammar?",
            /*2*/    "Which of the following is NOT true about unambiguous grammars?",
            /*3*/    "Ambiguity in a grammar means that:",
            /*4*/    "Which of the following methods can be used to check if a grammar is ambiguous?",
            /*5*/    "Which grammar property is crucial for ensuring that a programming language is parsed deterministically?",
            /*6*/    "Which is an example of unambiguous grammar?",
            /*7*/    "When is a grammar said to be unambiguous?",
            /*8*/    "Which is a common application of unambiguous grammars?",
            /*9*/    "What is the main drawback of unambiguous grammars?",
            /*10*/   "Which feature distinguishes an unambiguous grammar from an ambiguous one?",
            /*11*/   "How is ambiguity typically handled in grammar design?",
            /*12*/   "Which tool is typically used to check for unambiguous grammars?",
            /*13*/   "Which of the following is a benefit of using unambiguous grammars in compilers?",
            /*14*/   "Which of the following properties is essential for ensuring that a grammar is unambiguous?",
            /*15*/   "Which is NOT an approach for handling ambiguity in grammar?"
    };

    public static final String[][] post_test_lesson_2_choices_medium = {
            /*1*/    {"A grammar that generates exactly one parse tree for every valid string", "A grammar that generates multiple parse trees for the same string", "A grammar that allows context-sensitive derivations", "A grammar with no production rules"},
            /*2*/    {"They produce unique parse trees", "They can have multiple leftmost derivations", "They are preferred in the design of compilers", "They ensure deterministic parsing"},
            /*3*/    {"There is a conflict in the derivation rules", "Every string has more than one valid derivation", "The grammar generates a unique parse tree", "Multiple derivations exist for some strings"},
            /*4*/    {"Checking if each non-terminal has more than one production rule", "Constructing parse trees for different derivations of the same string", "Transforming it into Chomsky Normal Form", "None of the above"},
            /*5*/    {"Left recursion", "Ambiguity", "Unambiguity", "Right recursion"},
            /*6*/    {"A grammar that generates strings with a unique parse tree", "A grammar that allows multiple interpretations of a sentence", "A grammar that uses complex recursive rules", "A grammar that generates strings with several derivation paths"},
            /*7*/    {"When it generates strings with a unique derivation tree for each string", "When it has multiple ways to derive the same string", "When it contains no non-terminal symbols", "When every string has more than one valid interpretation"},
            /*8*/    {"Parsing natural languages", "Defining programming languages", "Generating ambiguous sentences", "Writing production rules for recursion"},
            /*9*/    {"They can be more complex and less intuitive than ambiguous grammars", "They limit the flexibility of language generation", "They may require more extensive rules to achieve unambiguity", "They generate multiple valid parse trees for the same string"},
            /*10*/   {"Rightmost derivation", "Unique parse tree for each string", "Use of non-terminal symbols", "Left recursion"},
            /*11*/   {"By removing production rules", "By introducing multiple derivations", "By rewriting the grammar to be unambiguous", "By adding more ambiguity"},
            /*12*/   {"Parse trees", "Terminal symbols", "Chomsky Normal Form", "Context-sensitive rules"},
            /*13*/   {"More flexibility in rule creation", "Deterministic parsing algorithms", "Simplified syntax generation", "Reduced parsing speed"},
            /*14*/   {"Every non-terminal symbol has a unique production rule", "The grammar has a unique derivation for each string", "All derivations lead to multiple parse trees", "All strings generated by the grammar are ambiguous"},
            /*15*/   {"Removing recursion", "Rewriting the grammar", "Introducing precedence rules", "Simplifying the production rules"}
    };

    public static final int[] post_test_lesson_2_answers_medium = {
            /*1*/    0,  // A grammar that generates exactly one parse tree for every valid string
            /*2*/    1,  // They can have multiple leftmost derivations
            /*3*/    3,  // Multiple derivations exist for some strings
            /*4*/    1,  // Constructing parse trees for different derivations of the same string
            /*5*/    2,  // Unambiguity
            /*6*/    0,  // A grammar that generates strings with a unique parse tree
            /*7*/    0,  // When it generates strings with a unique derivation tree for each string
            /*8*/    1,  // Defining programming languages
            /*9*/    0,  // They can be more complex and less intuitive than ambiguous grammars
            /*10*/   1,  // Unique parse tree for each string
            /*11*/   2,  // By rewriting the grammar to be unambiguous
            /*12*/   0,  // Parse trees
            /*13*/   1,  // Deterministic parsing algorithms
            /*14*/   1,  // The grammar has a unique derivation for each string
            /*15*/   0   // Removing recursion
    };

    /*
    +----------------------+
    |       POST-TEST      |
    |         HARD         |
    +----------------------+
    */

    public static e_Question[] get_PostTest_Lesson2_Hard_Questions() {
        return e_Module_6.get_PostTest_Hard_Questions(
                post_test_lesson_2_questions_hard,
                post_test_lesson_2_answers_hard,
                e_Question.Difficulty.HARD
        );
    }

    public static final String[] post_test_lesson_2_questions_hard = {
            /*1*/    "What type of grammar eliminates syntactic ambiguity?",
            /*2*/    "What ensures that every valid string has exactly one interpretation?",
            /*3*/    "What tool visually represents the structure of a sentence?",
            /*4*/    "What is used to detect ambiguity in grammar?",
            /*5*/    "What is essential for building deterministic parsers?",
            /*6*/    "What defines the structure of valid strings in a grammar?",
            /*7*/    "What type of grammar allows only one derivation per sentence?",
            /*8*/    "What eliminates multiple valid interpretations of a sentence?",
            /*9*/    "What ensures there are no conflicts in sentence structure?",
            /*10*/   "What helps compilers avoid multiple interpretations of code?",
            /*11*/   "What process is used to verify if a grammar is unambiguous?",
            /*12*/   "What prevents more than one parse tree for the same string?",
            /*13*/   "What is necessary for compilers to function efficiently?",
            /*14*/   "What kind of grammar helps define programming languages?",
            /*15*/   "What ensures sentences are processed correctly in programming?"
    };

    public static final String[] post_test_lesson_2_answers_hard = {
            /*1*/    "unambiguous grammar",
            /*2*/    "unique parsing",
            /*3*/    "parse tree",
            /*4*/    "tree comparison",
            /*5*/    "unambiguous rules",
            /*6*/    "grammar derivation",
            /*7*/    "deterministic grammar",
            /*8*/    "parsing clarity",
            /*9*/    "syntax rules",
            /*10*/   "grammar consistency",
            /*11*/   "parse analysis",
            /*12*/   "unique derivation",
            /*13*/   "syntactic unambiguity",
            /*14*/   "formal grammar",
            /*15*/   "grammar precision"
    };

}